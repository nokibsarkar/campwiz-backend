// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"strings"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"nokib/campwiz/models"
)

func newCommonsSubmissionEntry(db *gorm.DB, opts ...gen.DOOption) commonsSubmissionEntry {
	_commonsSubmissionEntry := commonsSubmissionEntry{}

	_commonsSubmissionEntry.commonsSubmissionEntryDo.UseDB(db, opts...)
	_commonsSubmissionEntry.commonsSubmissionEntryDo.UseModel(&models.CommonsSubmissionEntry{})

	tableName := _commonsSubmissionEntry.commonsSubmissionEntryDo.TableName()
	_commonsSubmissionEntry.ALL = field.NewAsterisk(tableName)
	_commonsSubmissionEntry.PageID = field.NewUint64(tableName, "page_id")
	_commonsSubmissionEntry.PageTitle = field.NewString(tableName, "page_title")
	_commonsSubmissionEntry.UserName = field.NewString(tableName, "user_name")
	_commonsSubmissionEntry.FrTimestamp = field.NewUint64(tableName, "fr_timestamp")
	_commonsSubmissionEntry.FrHeight = field.NewUint64(tableName, "fr_height")
	_commonsSubmissionEntry.FrWidth = field.NewUint64(tableName, "fr_width")
	_commonsSubmissionEntry.FrSize = field.NewUint64(tableName, "fr_size")
	_commonsSubmissionEntry.FtMediaType = field.NewString(tableName, "ft_media_type")

	_commonsSubmissionEntry.fillFieldMap()

	return _commonsSubmissionEntry
}

type commonsSubmissionEntry struct {
	commonsSubmissionEntryDo

	ALL         field.Asterisk
	PageID      field.Uint64
	PageTitle   field.String
	UserName    field.String
	FrTimestamp field.Uint64
	FrHeight    field.Uint64
	FrWidth     field.Uint64
	FrSize      field.Uint64
	FtMediaType field.String

	fieldMap map[string]field.Expr
}

func (c commonsSubmissionEntry) Table(newTableName string) *commonsSubmissionEntry {
	c.commonsSubmissionEntryDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c commonsSubmissionEntry) As(alias string) *commonsSubmissionEntry {
	c.commonsSubmissionEntryDo.DO = *(c.commonsSubmissionEntryDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *commonsSubmissionEntry) updateTableName(table string) *commonsSubmissionEntry {
	c.ALL = field.NewAsterisk(table)
	c.PageID = field.NewUint64(table, "page_id")
	c.PageTitle = field.NewString(table, "page_title")
	c.UserName = field.NewString(table, "user_name")
	c.FrTimestamp = field.NewUint64(table, "fr_timestamp")
	c.FrHeight = field.NewUint64(table, "fr_height")
	c.FrWidth = field.NewUint64(table, "fr_width")
	c.FrSize = field.NewUint64(table, "fr_size")
	c.FtMediaType = field.NewString(table, "ft_media_type")

	c.fillFieldMap()

	return c
}

func (c *commonsSubmissionEntry) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *commonsSubmissionEntry) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 8)
	c.fieldMap["page_id"] = c.PageID
	c.fieldMap["page_title"] = c.PageTitle
	c.fieldMap["user_name"] = c.UserName
	c.fieldMap["fr_timestamp"] = c.FrTimestamp
	c.fieldMap["fr_height"] = c.FrHeight
	c.fieldMap["fr_width"] = c.FrWidth
	c.fieldMap["fr_size"] = c.FrSize
	c.fieldMap["ft_media_type"] = c.FtMediaType
}

func (c commonsSubmissionEntry) clone(db *gorm.DB) commonsSubmissionEntry {
	c.commonsSubmissionEntryDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c commonsSubmissionEntry) replaceDB(db *gorm.DB) commonsSubmissionEntry {
	c.commonsSubmissionEntryDo.ReplaceDB(db)
	return c
}

type commonsSubmissionEntryDo struct{ gen.DO }

type ICommonsSubmissionEntryDo interface {
	gen.SubQuery
	Debug() ICommonsSubmissionEntryDo
	WithContext(ctx context.Context) ICommonsSubmissionEntryDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ICommonsSubmissionEntryDo
	WriteDB() ICommonsSubmissionEntryDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ICommonsSubmissionEntryDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ICommonsSubmissionEntryDo
	Not(conds ...gen.Condition) ICommonsSubmissionEntryDo
	Or(conds ...gen.Condition) ICommonsSubmissionEntryDo
	Select(conds ...field.Expr) ICommonsSubmissionEntryDo
	Where(conds ...gen.Condition) ICommonsSubmissionEntryDo
	Order(conds ...field.Expr) ICommonsSubmissionEntryDo
	Distinct(cols ...field.Expr) ICommonsSubmissionEntryDo
	Omit(cols ...field.Expr) ICommonsSubmissionEntryDo
	Join(table schema.Tabler, on ...field.Expr) ICommonsSubmissionEntryDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ICommonsSubmissionEntryDo
	RightJoin(table schema.Tabler, on ...field.Expr) ICommonsSubmissionEntryDo
	Group(cols ...field.Expr) ICommonsSubmissionEntryDo
	Having(conds ...gen.Condition) ICommonsSubmissionEntryDo
	Limit(limit int) ICommonsSubmissionEntryDo
	Offset(offset int) ICommonsSubmissionEntryDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ICommonsSubmissionEntryDo
	Unscoped() ICommonsSubmissionEntryDo
	Create(values ...*models.CommonsSubmissionEntry) error
	CreateInBatches(values []*models.CommonsSubmissionEntry, batchSize int) error
	Save(values ...*models.CommonsSubmissionEntry) error
	First() (*models.CommonsSubmissionEntry, error)
	Take() (*models.CommonsSubmissionEntry, error)
	Last() (*models.CommonsSubmissionEntry, error)
	Find() ([]*models.CommonsSubmissionEntry, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.CommonsSubmissionEntry, err error)
	FindInBatches(result *[]*models.CommonsSubmissionEntry, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*models.CommonsSubmissionEntry) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ICommonsSubmissionEntryDo
	Assign(attrs ...field.AssignExpr) ICommonsSubmissionEntryDo
	Joins(fields ...field.RelationField) ICommonsSubmissionEntryDo
	Preload(fields ...field.RelationField) ICommonsSubmissionEntryDo
	FirstOrInit() (*models.CommonsSubmissionEntry, error)
	FirstOrCreate() (*models.CommonsSubmissionEntry, error)
	FindByPage(offset int, limit int) (result []*models.CommonsSubmissionEntry, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ICommonsSubmissionEntryDo
	UnderlyingDB() *gorm.DB
	schema.Tabler

	FetchSubmissionsFromCommonsDBByCategory(categoryName string, startPageID uint64, minimumTimestamp uint64, maximumTimestamp uint64, limit int) (result []models.CommonsSubmissionEntry, err error)
}

// SLOW OK
//
// SELECT  page_id, page_title, user_name, fr_timestamp, fr_height, fr_width, fr_size, ft_media_type FROM categorylinks JOIN page JOIN file JOIN filerevision JOIN actor JOIN `user` JOIN filetypes ON ft_id = file_type AND fr_id=file_latest AND user_id=actor_user and cl_from=page_id and file_name=page_title and actor_id=fr_actor where cl_from > @startPageID and @minimumTimestamp <= fr_timestamp and fr_timestamp < @maximumTimestamp and cl_to=@categoryName and fr_deleted = false and file_deleted=false ORDER BY `page_id` ASC LIMIT @limit;
func (c commonsSubmissionEntryDo) FetchSubmissionsFromCommonsDBByCategory(categoryName string, startPageID uint64, minimumTimestamp uint64, maximumTimestamp uint64, limit int) (result []models.CommonsSubmissionEntry, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, startPageID)
	params = append(params, minimumTimestamp)
	params = append(params, maximumTimestamp)
	params = append(params, categoryName)
	params = append(params, limit)
	generateSQL.WriteString("SELECT page_id, page_title, user_name, fr_timestamp, fr_height, fr_width, fr_size, ft_media_type FROM categorylinks JOIN page JOIN file JOIN filerevision JOIN actor JOIN `user` JOIN filetypes ON ft_id = file_type AND fr_id=file_latest AND user_id=actor_user and cl_from=page_id and file_name=page_title and actor_id=fr_actor where cl_from > ? and ? <= fr_timestamp and fr_timestamp < ? and cl_to=? and fr_deleted = false and file_deleted=false ORDER BY `page_id` ASC LIMIT ?; ")

	var executeSQL *gorm.DB
	executeSQL = c.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

func (c commonsSubmissionEntryDo) Debug() ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.Debug())
}

func (c commonsSubmissionEntryDo) WithContext(ctx context.Context) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c commonsSubmissionEntryDo) ReadDB() ICommonsSubmissionEntryDo {
	return c.Clauses(dbresolver.Read)
}

func (c commonsSubmissionEntryDo) WriteDB() ICommonsSubmissionEntryDo {
	return c.Clauses(dbresolver.Write)
}

func (c commonsSubmissionEntryDo) Session(config *gorm.Session) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.Session(config))
}

func (c commonsSubmissionEntryDo) Clauses(conds ...clause.Expression) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c commonsSubmissionEntryDo) Returning(value interface{}, columns ...string) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c commonsSubmissionEntryDo) Not(conds ...gen.Condition) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c commonsSubmissionEntryDo) Or(conds ...gen.Condition) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c commonsSubmissionEntryDo) Select(conds ...field.Expr) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c commonsSubmissionEntryDo) Where(conds ...gen.Condition) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c commonsSubmissionEntryDo) Order(conds ...field.Expr) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c commonsSubmissionEntryDo) Distinct(cols ...field.Expr) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c commonsSubmissionEntryDo) Omit(cols ...field.Expr) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c commonsSubmissionEntryDo) Join(table schema.Tabler, on ...field.Expr) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c commonsSubmissionEntryDo) LeftJoin(table schema.Tabler, on ...field.Expr) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c commonsSubmissionEntryDo) RightJoin(table schema.Tabler, on ...field.Expr) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c commonsSubmissionEntryDo) Group(cols ...field.Expr) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c commonsSubmissionEntryDo) Having(conds ...gen.Condition) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c commonsSubmissionEntryDo) Limit(limit int) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c commonsSubmissionEntryDo) Offset(offset int) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c commonsSubmissionEntryDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c commonsSubmissionEntryDo) Unscoped() ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.Unscoped())
}

func (c commonsSubmissionEntryDo) Create(values ...*models.CommonsSubmissionEntry) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c commonsSubmissionEntryDo) CreateInBatches(values []*models.CommonsSubmissionEntry, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c commonsSubmissionEntryDo) Save(values ...*models.CommonsSubmissionEntry) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c commonsSubmissionEntryDo) First() (*models.CommonsSubmissionEntry, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.CommonsSubmissionEntry), nil
	}
}

func (c commonsSubmissionEntryDo) Take() (*models.CommonsSubmissionEntry, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.CommonsSubmissionEntry), nil
	}
}

func (c commonsSubmissionEntryDo) Last() (*models.CommonsSubmissionEntry, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.CommonsSubmissionEntry), nil
	}
}

func (c commonsSubmissionEntryDo) Find() ([]*models.CommonsSubmissionEntry, error) {
	result, err := c.DO.Find()
	return result.([]*models.CommonsSubmissionEntry), err
}

func (c commonsSubmissionEntryDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.CommonsSubmissionEntry, err error) {
	buf := make([]*models.CommonsSubmissionEntry, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c commonsSubmissionEntryDo) FindInBatches(result *[]*models.CommonsSubmissionEntry, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c commonsSubmissionEntryDo) Attrs(attrs ...field.AssignExpr) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c commonsSubmissionEntryDo) Assign(attrs ...field.AssignExpr) ICommonsSubmissionEntryDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c commonsSubmissionEntryDo) Joins(fields ...field.RelationField) ICommonsSubmissionEntryDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c commonsSubmissionEntryDo) Preload(fields ...field.RelationField) ICommonsSubmissionEntryDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c commonsSubmissionEntryDo) FirstOrInit() (*models.CommonsSubmissionEntry, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.CommonsSubmissionEntry), nil
	}
}

func (c commonsSubmissionEntryDo) FirstOrCreate() (*models.CommonsSubmissionEntry, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.CommonsSubmissionEntry), nil
	}
}

func (c commonsSubmissionEntryDo) FindByPage(offset int, limit int) (result []*models.CommonsSubmissionEntry, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c commonsSubmissionEntryDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c commonsSubmissionEntryDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c commonsSubmissionEntryDo) Delete(models ...*models.CommonsSubmissionEntry) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *commonsSubmissionEntryDo) withDO(do gen.Dao) *commonsSubmissionEntryDo {
	c.DO = *do.(*gen.DO)
	return c
}
